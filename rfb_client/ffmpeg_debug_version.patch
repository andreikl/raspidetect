diff --git a/libavcodec/dxva2.c b/libavcodec/dxva2.c
index b57ea21941..38bd52ff35 100644
--- a/libavcodec/dxva2.c
+++ b/libavcodec/dxva2.c
@@ -341,6 +341,8 @@ static int dxva2_get_decoder_configuration(AVCodecContext *avctx, const GUID *de
 
 static int dxva2_create_decoder(AVCodecContext *avctx)
 {
+    av_log(avctx, AV_LOG_ERROR, "dxva2_create_decoder\n");
+
     FFDXVASharedContext *sctx = DXVA_SHARED_CONTEXT(avctx);
     GUID *guid_list;
     unsigned guid_count;
@@ -408,6 +410,8 @@ static int dxva2_create_decoder(AVCodecContext *avctx)
     if (!sctx->decoder_ref)
         return AVERROR(ENOMEM);
 
+    av_log(avctx, AV_LOG_ERROR, "dxva2_create_decoder\n");
+    
     return 0;
 fail:
     return AVERROR(EINVAL);
@@ -660,6 +664,8 @@ int ff_dxva2_decode_init(AVCodecContext *avctx)
                             ? AV_HWDEVICE_TYPE_DXVA2 : AV_HWDEVICE_TYPE_D3D11VA;
     int ret = 0;
 
+    av_log(avctx, AV_LOG_ERROR, "ff_dxva2_decode_init\n");
+
     // Old API.
     if (avctx->hwaccel_context)
         return 0;
@@ -720,6 +726,7 @@ int ff_dxva2_decode_init(AVCodecContext *avctx)
     }
 #endif
 
+    av_log(avctx, AV_LOG_ERROR, "ff_dxva2_decode_init\n");
     return 0;
 
 fail:
@@ -890,6 +897,7 @@ int ff_dxva2_common_end_frame(AVCodecContext *avctx, AVFrame *frame,
                                                   DECODER_BUFFER_DESC *bs,
                                                   DECODER_BUFFER_DESC *slice))
 {
+    av_log(avctx, AV_LOG_ERROR, "ff_dxva2_common_end_frame\n");
     AVDXVAContext *ctx = DXVA_CONTEXT(avctx);
     unsigned               buffer_count = 0;
 #if CONFIG_D3D11VA
@@ -1025,11 +1033,14 @@ int ff_dxva2_common_end_frame(AVCodecContext *avctx, AVFrame *frame,
         hr = IDirectXVideoDecoder_Execute(DXVA2_CONTEXT(ctx)->decoder, &exec);
     }
 #endif
+    av_log(avctx, AV_LOG_ERROR, "dxva2 executed\n");
     if (FAILED(hr)) {
         av_log(avctx, AV_LOG_ERROR, "Failed to execute: 0x%x\n", (unsigned)hr);
         result = -1;
     }
 
+    av_log(avctx, AV_LOG_ERROR, "ff_dxva2_common_end_frame\n");
+    
 end:
 #if CONFIG_D3D11VA
     if (ff_dxva2_is_d3d11(avctx))
diff --git a/libavcodec/dxva2_h264.c b/libavcodec/dxva2_h264.c
index 5b23b28f12..2968bee13f 100644
--- a/libavcodec/dxva2_h264.c
+++ b/libavcodec/dxva2_h264.c
@@ -59,8 +59,11 @@ static void fill_picture_parameters(const AVCodecContext *avctx, AVDXVAContext *
                        ff_dxva2_get_surface_index(avctx, ctx, current_picture->f),
                        h->picture_structure == PICT_BOTTOM_FIELD);
     /* Configure the set of references */
+    //av_log(avctx, AV_LOG_ERROR, "pp->CurrPic: %x\n", pp->CurrPic);
     pp->UsedForReferenceFlags  = 0;
+    //av_log(avctx, AV_LOG_ERROR, "pp->UsedForReferenceFlags: %x\n", pp->UsedForReferenceFlags);
     pp->NonExistingFrameFlags  = 0;
+    //av_log(avctx, AV_LOG_ERROR, "pp->NonExistingFrameFlags: %x\n", pp->NonExistingFrameFlags);
     for (i = 0, j = 0; i < FF_ARRAY_ELEMS(pp->RefFrameList); i++) {
         const H264Picture *r;
         if (j < h->short_ref_count) {
@@ -87,16 +90,22 @@ static void fill_picture_parameters(const AVCodecContext *avctx, AVDXVAContext *
                 pp->UsedForReferenceFlags |= 1 << (2*i + 1);
         } else {
             pp->RefFrameList[i].bPicEntry = 0xff;
+            //av_log(avctx, AV_LOG_ERROR, "pp->RefFrameList[%d].bPicEntry: %x\n", i, pp->RefFrameList[i].bPicEntry);
             pp->FieldOrderCntList[i][0]   = 0;
+            //av_log(avctx, AV_LOG_ERROR, "pp->FieldOrderCntList[%d][0]: %x\n", i, pp->FieldOrderCntList[i][0]);
             pp->FieldOrderCntList[i][1]   = 0;
+            //av_log(avctx, AV_LOG_ERROR, "pp->FieldOrderCntList[%d][1]: %x\n", i, pp->FieldOrderCntList[i][1]);
             pp->FrameNumList[i]           = 0;
+            //av_log(avctx, AV_LOG_ERROR, "pp->FrameNumList[%d]: %x\n", i, pp->FrameNumList[i]);
         }
     }
 
     pp->wFrameWidthInMbsMinus1        = h->mb_width  - 1;
+    //av_log(avctx, AV_LOG_ERROR, "pp->wFrameWidthInMbsMinus1: %x\n", pp->wFrameWidthInMbsMinus1);
     pp->wFrameHeightInMbsMinus1       = h->mb_height - 1;
+    //av_log(avctx, AV_LOG_ERROR, "pp->wFrameHeightInMbsMinus1: %x\n", pp->wFrameHeightInMbsMinus1);
     pp->num_ref_frames                = sps->ref_frame_count;
-
+    //av_log(avctx, AV_LOG_ERROR, "pp->num_ref_frames: %x\n", pp->num_ref_frames);
     pp->wBitFields                    = ((h->picture_structure != PICT_FRAME) <<  0) |
                                         ((sps->mb_aff &&
                                         (h->picture_structure == PICT_FRAME)) <<  1) |
@@ -116,48 +125,78 @@ static void fill_picture_parameters(const AVCodecContext *avctx, AVDXVAContext *
                                         /* IntraPicFlag (Modified if we detect a non
                                          * intra slice in dxva2_h264_decode_slice) */
                                         (1                                    << 15);
-
+    //av_log(avctx, AV_LOG_ERROR, "pp->wBitFields: %x\n", pp->wBitFields);
     pp->bit_depth_luma_minus8         = sps->bit_depth_luma - 8;
+    //av_log(avctx, AV_LOG_ERROR, "pp->bit_depth_luma_minus8: %x\n", pp->bit_depth_luma_minus8);
     pp->bit_depth_chroma_minus8       = sps->bit_depth_chroma - 8;
+    //av_log(avctx, AV_LOG_ERROR, "pp->bit_depth_chroma_minus8: %x\n", pp->bit_depth_chroma_minus8);
     if (DXVA_CONTEXT_WORKAROUND(avctx, ctx) & FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG)
         pp->Reserved16Bits            = 0;
     else if (DXVA_CONTEXT_WORKAROUND(avctx, ctx) & FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO)
         pp->Reserved16Bits            = 0x34c;
     else
         pp->Reserved16Bits            = 3; /* FIXME is there a way to detect the right mode ? */
+    //av_log(avctx, AV_LOG_ERROR, "pp->Reserved16Bits: %x\n", pp->Reserved16Bits);
     pp->StatusReportFeedbackNumber    = 1 + DXVA_CONTEXT_REPORT_ID(avctx, ctx)++;
+    //av_log(avctx, AV_LOG_ERROR, "pp->StatusReportFeedbackNumber: %x\n", pp->StatusReportFeedbackNumber);
     pp->CurrFieldOrderCnt[0] = 0;
     if ((h->picture_structure & PICT_TOP_FIELD) &&
         current_picture->field_poc[0] != INT_MAX)
         pp->CurrFieldOrderCnt[0] = current_picture->field_poc[0];
+    //av_log(avctx, AV_LOG_ERROR, "pp->CurrFieldOrderCnt[0]: %x\n", pp->CurrFieldOrderCnt[0]);
+
     pp->CurrFieldOrderCnt[1] = 0;
     if ((h->picture_structure & PICT_BOTTOM_FIELD) &&
         current_picture->field_poc[1] != INT_MAX)
         pp->CurrFieldOrderCnt[1] = current_picture->field_poc[1];
+    //av_log(avctx, AV_LOG_ERROR, "pp->CurrFieldOrderCnt[1]: %x\n", pp->CurrFieldOrderCnt[1]);
+
     pp->pic_init_qs_minus26           = pps->init_qs - 26;
+    //av_log(avctx, AV_LOG_ERROR, "pp->pic_init_qs_minus26: %x\n", pp->pic_init_qs_minus26);
     pp->chroma_qp_index_offset        = pps->chroma_qp_index_offset[0];
+    //av_log(avctx, AV_LOG_ERROR, "pp->chroma_qp_index_offset: %x\n", pp->chroma_qp_index_offset);
     pp->second_chroma_qp_index_offset = pps->chroma_qp_index_offset[1];
+    //av_log(avctx, AV_LOG_ERROR, "pp->second_chroma_qp_index_offset: %x\n", pp->second_chroma_qp_index_offset);
     pp->ContinuationFlag              = 1;
+    //av_log(avctx, AV_LOG_ERROR, "pp->ContinuationFlag: %x\n", pp->ContinuationFlag);
     pp->pic_init_qp_minus26           = pps->init_qp - 26;
+    //av_log(avctx, AV_LOG_ERROR, "pp->pic_init_qp_minus26: %x\n", pp->pic_init_qp_minus26);
     pp->num_ref_idx_l0_active_minus1  = pps->ref_count[0] - 1;
+    //av_log(avctx, AV_LOG_ERROR, "pp->num_ref_idx_l0_active_minus1: %x\n", pp->num_ref_idx_l0_active_minus1);
     pp->num_ref_idx_l1_active_minus1  = pps->ref_count[1] - 1;
+    //av_log(avctx, AV_LOG_ERROR, "pp->num_ref_idx_l1_active_minus1: %x\n", pp->num_ref_idx_l1_active_minus1);
     pp->Reserved8BitsA                = 0;
+    //av_log(avctx, AV_LOG_ERROR, "pp->Reserved8BitsA: %x\n", pp->Reserved8BitsA);
     pp->frame_num                     = h->poc.frame_num;
+    //av_log(avctx, AV_LOG_ERROR, "pp->frame_num: %x\n", pp->frame_num);
     pp->log2_max_frame_num_minus4     = sps->log2_max_frame_num - 4;
+    //av_log(avctx, AV_LOG_ERROR, "pp->log2_max_frame_num_minus4: %x\n", pp->log2_max_frame_num_minus4);
     pp->pic_order_cnt_type            = sps->poc_type;
+    //av_log(avctx, AV_LOG_ERROR, "pp->pic_order_cnt_type: %x\n", pp->pic_order_cnt_type);
     if (sps->poc_type == 0)
         pp->log2_max_pic_order_cnt_lsb_minus4 = sps->log2_max_poc_lsb - 4;
     else if (sps->poc_type == 1)
         pp->delta_pic_order_always_zero_flag = sps->delta_pic_order_always_zero_flag;
+    //av_log(avctx, AV_LOG_ERROR, "pp->log2_max_pic_order_cnt_lsb_minus4: %x\n", pp->log2_max_pic_order_cnt_lsb_minus4);
+    //av_log(avctx, AV_LOG_ERROR, "pp->delta_pic_order_always_zero_flag: %x\n", pp->delta_pic_order_always_zero_flag);
     pp->direct_8x8_inference_flag     = sps->direct_8x8_inference_flag;
+    //av_log(avctx, AV_LOG_ERROR, "pp->direct_8x8_inference_flag: %x\n", pp->direct_8x8_inference_flag);
     pp->entropy_coding_mode_flag      = pps->cabac;
+    //av_log(avctx, AV_LOG_ERROR, "pp->entropy_coding_mode_flag: %x\n", pp->entropy_coding_mode_flag);
     pp->pic_order_present_flag        = pps->pic_order_present;
+    //av_log(avctx, AV_LOG_ERROR, "pp->pic_order_present_flag: %x\n", pp->pic_order_present_flag);
     pp->num_slice_groups_minus1       = pps->slice_group_count - 1;
+    //av_log(avctx, AV_LOG_ERROR, "pp->num_slice_groups_minus1: %x\n", pp->num_slice_groups_minus1);
     pp->slice_group_map_type          = pps->mb_slice_group_map_type;
+    //av_log(avctx, AV_LOG_ERROR, "pp->slice_group_map_type: %x\n", pp->slice_group_map_type);
     pp->deblocking_filter_control_present_flag = pps->deblocking_filter_parameters_present;
+    //av_log(avctx, AV_LOG_ERROR, "pp->deblocking_filter_control_present_flag: %x\n", pp->deblocking_filter_control_present_flag);
     pp->redundant_pic_cnt_present_flag= pps->redundant_pic_cnt_present;
+    //av_log(avctx, AV_LOG_ERROR, "pp->redundant_pic_cnt_present_flag: %x\n", pp->redundant_pic_cnt_present_flag);
     pp->Reserved8BitsB                = 0;
+    //av_log(avctx, AV_LOG_ERROR, "pp->Reserved8BitsB: %x\n", pp->Reserved8BitsB);
     pp->slice_group_change_rate_minus1= 0;  /* XXX not implemented by FFmpeg */
+    //av_log(avctx, AV_LOG_ERROR, "pp->slice_group_change_rate_minus1: %x\n", pp->slice_group_change_rate_minus1);
     //pp->SliceGroupMap[810];               /* XXX not implemented by FFmpeg */
 }
 
@@ -223,24 +262,38 @@ static void fill_slice_long(AVCodecContext *avctx, DXVA_Slice_H264_Long *slice,
 
     memset(slice, 0, sizeof(*slice));
     slice->BSNALunitDataLocation = position;
+    av_log(avctx, AV_LOG_ERROR, "slice->BSNALunitDataLocation: %d\n", slice->BSNALunitDataLocation);
     slice->SliceBytesInBuffer    = size;
+    av_log(avctx, AV_LOG_ERROR, "slice->SliceBytesInBuffer: %d\n", slice->SliceBytesInBuffer);
     slice->wBadSliceChopping     = 0;
+    av_log(avctx, AV_LOG_ERROR, "slice->wBadSliceChopping: %d\n", slice->wBadSliceChopping);
 
     slice->first_mb_in_slice     = (sl->mb_y >> FIELD_OR_MBAFF_PICTURE(h)) * h->mb_width + sl->mb_x;
+    av_log(avctx, AV_LOG_ERROR, "slice->first_mb_in_slice: %d\n", slice->first_mb_in_slice);
     slice->NumMbsForSlice        = 0; /* XXX it is set once we have all slices */
+    av_log(avctx, AV_LOG_ERROR, "slice->NumMbsForSlice: %d\n", slice->NumMbsForSlice);
     slice->BitOffsetToSliceData  = get_bits_count(&sl->gb) - 8;
+    av_log(avctx, AV_LOG_ERROR, "slice->BitOffsetToSliceData: %d\n", slice->BitOffsetToSliceData);
     slice->slice_type            = ff_h264_get_slice_type(sl);
     if (sl->slice_type_fixed)
         slice->slice_type += 5;
+    av_log(avctx, AV_LOG_ERROR, "slice->slice_type: %d\n", slice->slice_type);
     slice->luma_log2_weight_denom       = sl->pwt.luma_log2_weight_denom;
+    av_log(avctx, AV_LOG_ERROR, "slice->luma_log2_weight_denom: %d\n", slice->luma_log2_weight_denom);
     slice->chroma_log2_weight_denom     = sl->pwt.chroma_log2_weight_denom;
+    av_log(avctx, AV_LOG_ERROR, "slice->chroma_log2_weight_denom: %d\n", slice->chroma_log2_weight_denom);
     if (sl->list_count > 0)
         slice->num_ref_idx_l0_active_minus1 = sl->ref_count[0] - 1;
     if (sl->list_count > 1)
         slice->num_ref_idx_l1_active_minus1 = sl->ref_count[1] - 1;
+    av_log(avctx, AV_LOG_ERROR, "slice->num_ref_idx_l0_active_minus1: %d\n", slice->num_ref_idx_l0_active_minus1);
+    av_log(avctx, AV_LOG_ERROR, "slice->num_ref_idx_l1_active_minus1: %d\n", slice->num_ref_idx_l1_active_minus1);
     slice->slice_alpha_c0_offset_div2   = sl->slice_alpha_c0_offset / 2;
+    av_log(avctx, AV_LOG_ERROR, "slice->slice_alpha_c0_offset_div2: %d\n", slice->slice_alpha_c0_offset_div2);
     slice->slice_beta_offset_div2       = sl->slice_beta_offset     / 2;
+    av_log(avctx, AV_LOG_ERROR, "slice->slice_beta_offset_div2: %d\n", slice->slice_beta_offset_div2);
     slice->Reserved8Bits                = 0;
+    av_log(avctx, AV_LOG_ERROR, "slice->Reserved8Bits: %d\n", slice->Reserved8Bits);
 
     for (list = 0; list < 2; list++) {
         unsigned i;
@@ -255,6 +308,7 @@ static void fill_slice_long(AVCodecContext *avctx, DXVA_Slice_H264_Long *slice,
                     index = get_refpic_index(pp, ff_dxva2_get_surface_index(avctx, ctx, r->f));
                 fill_picture_entry(&slice->RefPicList[list][i], index,
                                    sl->ref_list[list][i].reference == PICT_BOTTOM_FIELD);
+                //av_log(avctx, AV_LOG_ERROR, "slice->RefPicList[%d][%d]: %d\n", list, i, slice->RefPicList[list][i]);
                 for (plane = 0; plane < 3; plane++) {
                     int w, o;
                     if (plane == 0 && sl->pwt.luma_weight_flag[list]) {
@@ -270,28 +324,40 @@ static void fill_slice_long(AVCodecContext *avctx, DXVA_Slice_H264_Long *slice,
                     }
                     slice->Weights[list][i][plane][0] = w;
                     slice->Weights[list][i][plane][1] = o;
+                    //av_log(avctx, AV_LOG_ERROR, "slice->Weights[%d][%d][%d][0]: %d\n", list, i, plane, slice->Weights[list][i][plane][0]);
+                    //av_log(avctx, AV_LOG_ERROR, "slice->Weights[%d][%d][%d][0]: %d\n", list, i, plane, slice->Weights[list][i][plane][1]);
                 }
             } else {
                 unsigned plane;
                 slice->RefPicList[list][i].bPicEntry = 0xff;
+                //av_log(avctx, AV_LOG_ERROR, "slice->RefPicList[%d][%d].bPicEntry: %d\n", list, i, slice->RefPicList[list][i].bPicEntry);
                 for (plane = 0; plane < 3; plane++) {
                     slice->Weights[list][i][plane][0] = 0;
                     slice->Weights[list][i][plane][1] = 0;
+                    //av_log(avctx, AV_LOG_ERROR, "slice->Weights[%d][%d][%d][0]: %d\n", list, i, plane, slice->Weights[list][i][plane][0]);
+                    //av_log(avctx, AV_LOG_ERROR, "slice->Weights[%d][%d][%d][0]: %d\n", list, i, plane, slice->Weights[list][i][plane][1]);
                 }
             }
         }
     }
     slice->slice_qs_delta    = 0; /* XXX not implemented by FFmpeg */
+    av_log(avctx, AV_LOG_ERROR, "slice->slice_qs_delta: %d\n", slice->slice_qs_delta);
     slice->slice_qp_delta    = sl->qscale - h->ps.pps->init_qp;
+    av_log(avctx, AV_LOG_ERROR, "slice->slice_qp_delta: %d\n", slice->slice_qp_delta);
     slice->redundant_pic_cnt = sl->redundant_pic_count;
+    av_log(avctx, AV_LOG_ERROR, "slice->redundant_pic_cnt: %d\n", slice->redundant_pic_cnt);
     if (sl->slice_type == AV_PICTURE_TYPE_B)
         slice->direct_spatial_mv_pred_flag = sl->direct_spatial_mv_pred;
+    av_log(avctx, AV_LOG_ERROR, "slice->direct_spatial_mv_pred_flag: %d\n", slice->direct_spatial_mv_pred_flag);
     slice->cabac_init_idc = h->ps.pps->cabac ? sl->cabac_init_idc : 0;
+    av_log(avctx, AV_LOG_ERROR, "slice->cabac_init_idc: %d\n", slice->cabac_init_idc);
     if (sl->deblocking_filter < 2)
         slice->disable_deblocking_filter_idc = 1 - sl->deblocking_filter;
     else
         slice->disable_deblocking_filter_idc = sl->deblocking_filter;
+    av_log(avctx, AV_LOG_ERROR, "slice->disable_deblocking_filter_idc: %d\n", slice->disable_deblocking_filter_idc);
     slice->slice_id = h->current_slice - 1;
+    av_log(avctx, AV_LOG_ERROR, "slice->slice_id: %d\n", slice->slice_id);
 }
 
 static int commit_bitstream_and_slice_buffer(AVCodecContext *avctx,
@@ -442,6 +508,7 @@ static int dxva2_h264_start_frame(AVCodecContext *avctx,
                                   av_unused const uint8_t *buffer,
                                   av_unused uint32_t size)
 {
+    av_log(avctx, AV_LOG_ERROR, "dxva2_h264_start_frame\n");
     const H264Context *h = avctx->priv_data;
     AVDXVAContext *ctx = DXVA_CONTEXT(avctx);
     struct dxva2_picture_context *ctx_pic = h->cur_pic_ptr->hwaccel_picture_private;
@@ -459,6 +526,7 @@ static int dxva2_h264_start_frame(AVCodecContext *avctx,
     ctx_pic->slice_count    = 0;
     ctx_pic->bitstream_size = 0;
     ctx_pic->bitstream      = NULL;
+    av_log(avctx, AV_LOG_ERROR, "dxva2_h264_start_frame\n");
     return 0;
 }
 
@@ -466,6 +534,8 @@ static int dxva2_h264_decode_slice(AVCodecContext *avctx,
                                    const uint8_t *buffer,
                                    uint32_t size)
 {
+    av_log(avctx, AV_LOG_ERROR, "dxva2_h264_decode_slice\n");
+
     const H264Context *h = avctx->priv_data;
     const H264SliceContext *sl = &h->slice_ctx[0];
     AVDXVAContext *ctx = DXVA_CONTEXT(avctx);
@@ -491,11 +561,15 @@ static int dxva2_h264_decode_slice(AVCodecContext *avctx,
 
     if (sl->slice_type != AV_PICTURE_TYPE_I && sl->slice_type != AV_PICTURE_TYPE_SI)
         ctx_pic->pp.wBitFields &= ~(1 << 15); /* Set IntraPicFlag to 0 */
+
+    av_log(avctx, AV_LOG_ERROR, "dxva2_h264_decode_slice\n");
     return 0;
 }
 
 static int dxva2_h264_end_frame(AVCodecContext *avctx)
 {
+    av_log(avctx, AV_LOG_ERROR, "dxva2_h264_end_frame\n");
+
     H264Context *h = avctx->priv_data;
     H264SliceContext *sl = &h->slice_ctx[0];
     struct dxva2_picture_context *ctx_pic =
@@ -510,6 +584,8 @@ static int dxva2_h264_end_frame(AVCodecContext *avctx)
                                     commit_bitstream_and_slice_buffer);
     if (!ret)
         ff_h264_draw_horiz_band(h, sl, 0, h->avctx->height);
+
+    av_log(avctx, AV_LOG_ERROR, "dxva2_h264_end_frame\n");
     return ret;
 }
 
diff --git a/libavcodec/h264_picture.c b/libavcodec/h264_picture.c
index eec5e9fb9a..61370bd6fd 100644
--- a/libavcodec/h264_picture.c
+++ b/libavcodec/h264_picture.c
@@ -162,6 +162,8 @@ int ff_h264_field_end(H264Context *h, H264SliceContext *sl, int in_setup)
     int err = 0;
     h->mb_y = 0;
 
+    av_log(avctx, AV_LOG_ERROR, "ff_h264_field_end\n");
+
     if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {
         if (!h->droppable) {
             err = ff_h264_execute_ref_pic_marking(h);
@@ -185,6 +187,7 @@ int ff_h264_field_end(H264Context *h, H264SliceContext *sl, int in_setup)
     emms_c();
 
     h->current_slice = 0;
+    av_log(avctx, AV_LOG_ERROR, "ff_h264_field_end\n");
 
     return err;
 }
diff --git a/libavcodec/h264dec.c b/libavcodec/h264dec.c
index 47b9abbc5c..450e8bf63d 100644
--- a/libavcodec/h264dec.c
+++ b/libavcodec/h264dec.c
@@ -619,13 +619,16 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)
         case H264_NAL_SLICE:
             h->has_slice = 1;
 
-            if ((err = ff_h264_queue_decode_slice(h, nal))) {
+            if (ff_h264_queue_decode_slice(h, nal)) {
                 H264SliceContext *sl = h->slice_ctx + h->nb_slice_ctx_queued;
                 sl->ref_count[0] = sl->ref_count[1] = 0;
                 break;
             }
 
+            av_log(avctx, AV_LOG_ERROR, "avctx->hwaccel: %d\n", avctx->hwaccel != NULL);
+
             if (h->current_slice == 1) {
+                av_log(avctx, AV_LOG_ERROR, "h->avctx->hwaccel->start_frame\n");
                 if (avctx->active_thread_type & FF_THREAD_FRAME &&
                     i >= nals_needed && !h->setup_finished && h->cur_pic_ptr) {
                     ff_thread_finish_setup(avctx);
@@ -635,10 +638,13 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)
                 if (h->avctx->hwaccel &&
                     (ret = h->avctx->hwaccel->start_frame(h->avctx, buf, buf_size)) < 0)
                     goto end;
+
+                av_log(avctx, AV_LOG_ERROR, "h->avctx->hwaccel->start_frame\n");
             }
 
             max_slice_ctx = avctx->hwaccel ? 1 : h->nb_slice_ctx;
             if (h->nb_slice_ctx_queued == max_slice_ctx) {
+                av_log(avctx, AV_LOG_ERROR, "avctx->hwaccel->decode_slice\n");
                 if (h->avctx->hwaccel) {
                     ret = avctx->hwaccel->decode_slice(avctx, nal->raw_data, nal->raw_size);
                     h->nb_slice_ctx_queued = 0;
@@ -646,6 +652,8 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)
                     ret = ff_h264_execute_decode_slices(h);
                 if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
                     goto end;
+
+                av_log(avctx, AV_LOG_ERROR, "avctx->hwaccel->decode_slice\n");
             }
             break;
         case H264_NAL_DPA:
@@ -682,6 +690,7 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)
             break;
         }
         case H264_NAL_PPS:
+            av_log(avctx, AV_LOG_ERROR, "avctx->hwaccel->decode_params\n");
             if (avctx->hwaccel && avctx->hwaccel->decode_params) {
                 ret = avctx->hwaccel->decode_params(avctx,
                                                     nal->type,
@@ -694,6 +703,7 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)
                                                        nal->size_bits);
             if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))
                 goto end;
+            av_log(avctx, AV_LOG_ERROR, "avctx->hwaccel->decode_params\n");
             break;
         case H264_NAL_AUD:
         case H264_NAL_END_SEQUENCE:
@@ -908,14 +918,14 @@ static int finalize_frame(H264Context *h, AVFrame *dst, H264Picture *out, int *g
 
         *got_frame = 1;
 
-        if (CONFIG_MPEGVIDEO) {
+        /*if (CONFIG_MPEGVIDEO) {
             ff_print_debug_info2(h->avctx, dst, NULL,
                                  out->mb_type,
                                  out->qscale_table,
                                  out->motion_val,
                                  NULL,
                                  h->mb_width, h->mb_height, h->mb_stride, 1);
-        }
+        }*/
     }
 
     return 0;
@@ -1005,8 +1015,9 @@ static int h264_decode_frame(AVCodecContext *avctx, void *data,
         return AVERROR_INVALIDDATA;
     }
 
+    av_log(avctx, AV_LOG_ERROR, "h->mb_y: %d, h->mb_height: %d\n", h->mb_y, h->mb_height);
     if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||
-        (h->mb_y >= h->mb_height && h->mb_height)) {
+        (h->mb_height && h->mb_height)) {
         if ((ret = ff_h264_field_end(h, &h->slice_ctx[0], 0)) < 0)
             return ret;
 
